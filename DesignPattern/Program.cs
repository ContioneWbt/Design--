using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DesignPattern
{
    /// <summary>
    /// 1 创建型设计模式
    /// 2 结构型设计模式
    /// 3 行为型设计模式
    /// 
    /// 设计模式六大原则：单一职责 里氏替换 依赖倒置 最小接口 迪米特 开闭
    ///                   这些只能叫原则,叫建议,没有实际的招数
    /// 面向对象23种设计模式：面向对象语言开发过程中，遇到的种种场景和问题，提出了解决方案和思路，
    ///                       沉淀下来就变成了设计模式
    ///                       解决具体问题的具体招数---套路---站在前辈的肩膀上
    ///                       
    /// 创建型设计模式：关注对象的创建
    /// 结构型设计模式：关注类与类之间的关系
    /// 行为型设计模式：关注对象和行为的分离
    /// 
    /// 就是学习核心套路
    /// 
    /// 0122
    /// 创建型设计模式5：关注对象的创建，
    /// 对象的创建不就是new()一下？其实有很多套路
    /// 单例模式：就是限制了对象的创建，重用了对象
    /// 原型模式：换个方式创建对象，不走构造函数，而是内存拷贝
    /// 简单工厂：不直接new，把对象创建转移到工厂类
    /// (简单工厂不属于23种设计模式)
    /// 工厂方法：屏蔽对象的创建；留下了扩展空间；
    /// 抽象工厂：屏蔽对象的创建；约束强制保障产品簇；
    /// 建造者模式：复杂的工厂方法
    /// 
    /// 
    /// 没有什么设计模式是完美无缺的，一个设计模式就是解决一类的问题的，通常设计模式在解决一类问题的同时，还会带来别的问题，我们设计者要做的事儿，就是要扬长避短，充分发挥长处！
    /// 
    /// 0123
    /// 高级班的传统，准备好学习的小伙伴儿，给Eleven老师刷个专属字母E，然后课程就正式开始了！！！
    /// 结构型设计模式7：关注类与类之间的关系
    /// 纵向关系：继承≈≈实现  超强关联
    /// 横向关系：>组合>聚合>关联>依赖
    ///           依赖是出现在方法内部
    ///           另外三个是用语义区分的，可能都是一个属性
    ///           Person类 有个大脑Header属性  组合(同生共死)
    ///           Person类 有个手/脚    聚合(成人)
    ///           Person类 有个iPhone属性  关联(非必须)   
    /// 组合优于继承，结构型设计模式的核心
    /// 
    /// 
    /// 适配器模式：解决重构的问题，新东西和旧系统不吻合，通过继承/组合进行适配
    /// 代理模式：通过代理完成对业务类的访问，包一层方便任意功能扩展
    /// 装饰器模式：通过组合+继承，完成对象功能动态扩展
    /// 外观模式，组合模式，桥接模式，享元模式
    /// 
    /// 多种结构型设计模式其实都是用组合包一层，然后加功能，
    /// 解决不同的问题，然后有不同的侧重点，也有不同的规范
    /// 
    /// 0124
    /// 高级班的传统，准备好学习的小伙伴儿，给Eleven老师刷个专属字母E，然后课程就正式开始了！！！
    /// 行为型设计模式11：关注对象和行为的分离
    /// 模板方法设计模式：在基类父类定义流程，把可变逻辑分离到不同子类实现
    /// 观察者模式：一个对象动作触发多个对象的行为，通过观察者可以去掉对象的依赖，支持各种自定义和扩展
    /// 责任链模式：请求的处理流程，沿着链子顺序执行，还运行链子扩展和订制
    /// 
    /// 
    /// 甩锅大法：把锅丢出去，只管自己，哪管洪水滔天
    ///           把不稳定的地方移出去，自己只写稳定的，能保证自身的稳定
    ///           
    /// 
    /// 没有什么设计模式是完美无缺的，一个设计模式就是解决一类的问题的，通常设计模式在解决一类问题的同时，还会带来别的问题，我们设计者要做的事儿，就是要扬长避短，充分发挥长处！
    /// 
    /// 很多时候，可能会融合应用多个设计模式，分别解决对应的问题
    /// </summary>
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Console.WriteLine("欢迎来到.Net高级班课程，今晚学习设计模式");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
            Console.Read();
        }
    }
}
